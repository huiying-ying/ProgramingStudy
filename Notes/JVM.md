# JVM

· 请你谈谈你对VM的理解？java8虚拟机和之前的变化更新？
· 什么是OOM,什么是栈溢出StackOverFlowError?怎么分析？
· VM的常用调优参数有哪些？
· 内存快照如何抓取，怎么分析Dump文件？知道吗？
· 谈谈VM中，类加载器你的认识？

## 1 JVM的位置

![image-20220914152502396](imgs\JVM\image-20220914152502396.png)

其中JRE 包含了  JVM

## 2 JVM的体系结构

![image-20220914154648159](imgs\JVM\image-20220914154648159.png)

## 3 类加载器

作用：类加载器是 jre 的一部分，负责动态将类（.class文件）添加到 Java 虚拟机。

实例放在堆里面

1. 虚拟机自带的加载器
2. 启动类（根）加载器  bootstrap classloader ：加载jre/lib/rt.jar
3. 扩展类加载器  extension classloader ：加载jre/lib/ext/*.jar
4. 应用程序（系统类）加载器  application classloader：加载classpath上指定的类库

## 4 双亲委派机制

**双亲委派机制 ** 是指当一个类加载器收到一个类加载请求时，该类加载器首先会把请求委派给父类加载器。每个类加载器都是如此，只有在父类加载器在自己的搜索范围内找不到指定类时，子类加载器才会尝试自己去加载。



![image-20220914162452401](imgs\JVM\image-20220914162452401.png)

在获得类加载器的过程中，调用的顺序

1. 类加载器收到类加载的清求
2. 将这个请求向上委托给**父类加载器**去完成，一直向上委托，直到启动类加载器

3. 启动加载器检查是否能够加载当前这个类，能加载就结束，使用当前的加载器，否则，抛出异常，通知子加载器进行加载
4. 重复步骤3

也可以表示为

1. APP-->EXC-->BOOT（最终执行）

2. BOOT

3. EXC

4. APP


## 5 沙箱安全机制

Java 安全模型的核心就是 Java 沙箱(sandbox),，什么是沙箱？沙箱是一个限制程序运行的环境。沙箱机制就是将Java代码限定在虚拟机 JVM 特定的运行范围中，并且严格限制代码对本地系统资源访问，通过这样的措施来保
证对代码的有效隔离，防止对本地系统造成破坏。沙箱主要限制系统资源访问，那系统资源包括什么？CPU、内
存、文件系统、网络。不同级别的沙箱对这些资源访问的限制也可以不一样。

所有的 java 程序运行都可以指定沙箱，可以定制安全策略。

在 java 中将执行程序分成 **本地代码** 和 **远程代码** 两种，本地代码默认视为可信任的，而远程代码则被看作是不受信的。对于授信的本地代码，可以访问一切本地资源。而对于非授信的远程代码在早期 java 实现中，安全依赖于沙箱(Sandbox)机制。如下图所示 JDK1.0 安全模型。

![image-20220914165602038](imgs\JVM\image-20220914165602038.png)

但如此严格的安全机制也给程序的功能扩展带来障碍，比如当用户希望远程代码访问本地系统的文件时候，就
无法实现。因此在后续的 java1.1 版本中，针对安全机制做了改进，增加了 **安全策略**，允许用户指定代码对本地资源的访问权限。如下图所示 JDK1.1安全模型。

![image-20220914165740937](imgs\JVM\image-20220914165740937.png)

在 java1.2版本中，再次改进了安全机制，增加了 **代码签名** 。不论本地代码或是远程代码，都会按照用户的安全
策略设定，由类加载器加载到虚拟机中权限不同的运行空间，来实现差异化的代码执行权限控制。如下图所示
JDK1.2 安全模型

![image-20220914170214174](imgs\JVM\image-20220914170214174.png)

当前最新的安全机制实现，则引入了域(Domain)的概念。虚拟机会把所有代码加载到不同的系统域和应用域，
系统域部分专门负责与关键资源进行交互，而各个应用域部分则通过系统域的部分代理来对各种需要的资源进行访
问。虚拟机中不同的受保护域(Protected Domain),对应不一样的权限(Permission)。存在于不同域中的类文件
就具有了当前域的全部权限，如下图所示最新的安全模型(JDK1.6)。

![image-20220914173738471](imgs\JVM\image-20220914173738471.png)

组成沙箱的基本组件：

- `字节码校验碧`(bytecode verifier)：确保 java 类文件遵循 java 语言规范。这样可以帮ava程序实现内存保护。但并不是所有的类文件都会经过字节码校验，比如核心类，如 java javax 开头的。

- 类装载器(class loader):其中类装载器在3个方面对ava沙箱起作用

  - 它防止恶意代码去干涉善意的代码；// 双亲委派机制

  - 它守护了被信任的类库边界：

  - 它将代码归入保护域，确定了代码可以进行哪些操作。

    虚拟机为不同的类加载器载入的类提供不同的命名空间，命名空间由一系列唯一的名称组成，每一个被装载的类将有一个名字，这个命名空间是由 java 虚拟机为每一个类装载器维护的，它们互相之间甚至不可见。

类装载器采用的机制是双亲委派模式。

1,从最内层M自带类加载器开始加载，外层恶意同名类得不到加载从而无法使用：
2.由于严格通过包来区分了访问域，外层恶意的类通过内置代码也无法获得权限访问到内层类，破坏代码就自然
无法生效。

- 存取控制器(access controller)：存取控制器可以控制核心API对操作系统的存取权限，而这个控制的策略
  设定，可以由用户指定。
- 安全管理器(security manager):是核心API和操作系统之间的主要接口。实现权限控制，比存取控制器优
  先级高。
- 安全软件包(security package):java.security下的类和扩展包下的类，允许用户为自己的应用增加新的安
  全特性，包括：
  - 安全提供者
  - 消息摘要
  - 数字签名 keytools
  - 加密
  - 鉴别

## 6 Native

Native 作为关键字修饰的方法像一个接口一样没有方法体，并且 java 作用不到，是调用C语言。

```java
private native void start0();
```

![image-20220915154919585](imgs\JVM\image-20220915154919585.png)

会进入本地方法栈
调用本地方法本地按口 JNI

#### JNI 作用

——扩展 java 的使用，融合不同的编程语言为的 java 所用！

目前该方法使用的越来越少了，除非是与硬件有关的应用，比如通过 java 程序驱动打印机或者 java 系统管理生产
设备，在企业级应用中已经比较少见。因为现在的异构领域间通信很发达，比如可以使用 Socket 通信，也可以使
用 Web Service 等等，不多做介绍！
Native Method Stack
它的具体做法是 Native Method Stack 中登记 native 方法，在(Execution Engine)执行引擎执行的时候加载
Native Libraies。【本地库】

## 7 PC寄存器

程序i计数器：Program Counter Register
每个线程都有一个程序计数器，是线程私有的，就是一个指针，指向方法区中的方法字节码（用来存储指向像
一条指令的地址，也即将要执行的指令代码），在执行引擎读取下一条指令，是一个非常小的内存空间，几乎可以
忽略不计

## 8 方法区 

Method Area 方法区——static, final, class, 常量池

方法区是被所有线程共享，所有字段和方法字节码，以及一些特殊方法，如构造函数，接口代码也在此定义。

简单说，所有定义的方法的信息都保存在该区域，**此区域属于共享区间**：

静态变量、常量、类信息(构造方法、接口定义)、运行时的常量池存在方法区中，但是实例变量存在堆内存中，和方法区无关。

## 9 栈

SSH, SSM查一下什么东西

主管程序的运行，生命周期和线程同步

线程结束，栈内存也就是释放，对于栈来说，不存在垃圾回收问题，一旦线程结束，栈就Over!

栈—— 8大基本类型+对象引用+实例的方法

**程序正在执行的方法一定在栈的顶部**（以不同的进程为例，下图展现程序当前执行的进程也一定在栈的顶部）

 ![image-20220915195456997](imgs\JVM\image-20220915195456997.png)

理解栈、堆、方法区之间的关系

![image-20220915201722100](imgs\JVM\image-20220915201722100.png)

**画出一个对象实例化过程在内存中的表示**

## 10 三种 JVM

- Sun ： HotSpot Java Hotspot(TM)64-Bit server VM (build 25.181-b13,mixed mode)
- BEA ： JRockit
- IBM ： J9 VM

## 11 堆

一个 JVM 只有一个堆内存，堆内存大小是可以调节的。

![image-20220915202932770](imgs\JVM\image-20220915202932770.png)

数据清理内存占用顺序：

1. 伊甸园区没有被清理的数据满了之后触发轻GC，活下来的会进入幸存区，
2. 幸存区有两个地方，在这里经过动态的有限次筛选清理后，触发重GC
3. 进入养老区，养老区也满了之后实行重GC

- GC 垃圾回收，主要是在**伊甸园区**和**养老区**。 

假设内存满了，会报错误**OOM**，堆内存不够！java.lang.OutOfMemoryError::Java heap space

在到 JDK8 以后，永久存储区改了个名字（元空间）；

## 12 新生区、老年区、永久区

这个区域常驻内存的。用来存放DK自身携带的Class对象。Interface元数据，存储的是java运行时的一些环境或类信息，这个区域不存在垃圾回收，关闭虚拟机就会释放这个区域的内存。

一个启动类，加载了大量的第三方jar包。Tomcat部署了太多的应用，大量动态生成的反射类。不断的被加载。直
到内存满，就会出现OOM。

- jdk1.6之前：永久代，常量池是在方法区；
- jdk1.7：永久代，但是慢慢的退化了，去永久代，常量池在堆中
- jdk1.8之后：无永久代，常量池在元空间

![image-20220917221619045](imgs\JVM\image-20220917221619045.png)

方法区是所有线程可以共享的

获取虚拟机内存相关数据

```java
// 返回虚拟机试图使用的最大内存
long max = Runtime.getRuntime().maxMemory(); //1024 1024
// 返回5vm的总内存
long total = Runtime.getRuntime().totalMemory();
System.out.println("max="+max+"\t"+(max/(double)1024/1024)+"MB");
System.out.println("total="+max+"\t"+(total/(double)1024/1024)+"MB");
// 默认情况下：分配的总内存是电脑内存的1/4，而初始化的内存：1/64
// 305664K+699392K=1,005,856K=981.5M
```

可以设置JVM总内存和初始内存都是1024

![image-20220917223248739](imgs\JVM\image-20220917223248739.png)



OOM:
1.尝试扩大推内存看结果
2.分析内存，看一下那个地方出现了问题（专业工具）

在一个项目中，突然出现了OOM故障，那么该如何排除~研究为什么出错~

- 能够看到代码第几行出错：内存快照分析工具，MAT，Jprofiler
- Dubug,一行行分析代码！

MAT，Jprofiler作用

- 分析Dump内存文件，快速定位内存泄露：
- 获得堆中的数据
- 获得大的对象~

### 12.2 使用 JProfilter

构建无限创建对象的代码

```java
public class test01 {

    byte[] array = new byte[1*1024*1024];

    public static void main(String[] args) {
        ArrayList<test01> list = new ArrayList<>();
        int count = 0;
        try{
            while (true){
                list.add(new test01());
                count++;
            }
        }catch (OutOfMemoryError e){
            e.printStackTrace();
        }

    }
}
```

VM options 设置

```
-Xms1m -Xmx8m -XX:+HeapDumpOnOutOfMemoryError
```

- -Xms1m   设置初始化内存分配大小，默认1/64
- -Xmx8m   设置最大分配内存，默认1/4
- -XX:+PrintGCDetails  打印GC垃圾回收信息
- -XX:+HeapDumpOnOutOfMemoryError   OOM DUMP

## 13 堆内存调优

相关题目 

- VM的内存模型和分区~详细到每个区放什么？
- 堆里面的分区有哪些？Eden,form,to,老年区，说说他们的特点！
- GC的算法有哪些？标记清除法，标记压缩，复制算法，引用计数器，怎么用的？
- 轻GC和重GC分别在什么时候发生？



## 14 GC--常用算法

#### 引用计数器

为每个对象分配一个计数器，如果一直没有用（一直为0）就清理。

缺点：计数器额外消耗了内存，且效率并不是很高

#### 复制算法

年轻代主要使用复制算法

![image-20220918123709184](imgs\JVM\image-20220918123709184.png)

每一次轻GC之后，To区是空的，From区收纳了所有从新生区和之前的From区（现在的To区）中活下来的，

![image-20220918124744041](imgs\JVM\image-20220918124744041.png)

优点：没有内存碎片

缺点：浪费了内存空间，在对象100%存活时效率低

即，复制算法最佳使用场景是**对象存活较低**的时候，也就是**新生区**。

#### 标记清除算法

![image-20220918125308815](imgs\JVM\image-20220918125308815.png)

- 优点：不需要额外的空间
- 缺点：两次扫描严重浪费时间，会产生内存碎片

#### 标记压缩算法

- 优点：防止内存碎片产生
- 缺点：多了一次移动成本

![image-20220918125555190](imgs\JVM\image-20220918125555190.png)

把两者结合一下，可以先清除几次，再压缩一次，即标记清除压缩算法。

## 15 总结

- 内存效率：复制算法>标记清除算法>标记压缩算法（时间复杂度）
- 内存整齐度：复制算法=标记压缩算法>标记清除算法
- 内存利用率：标记压缩算法=标记清除算法>复制算法

在不同的场景选择适合的算法

年轻代：  存活率低   -->  复制算法！
老年代：  区域大：存活率  -->  标记清除（内存碎片不是太多）+标记压缩混合实现

单点登录-- SSO

## 16 JMM

1.什么是MM?
JMM:(Java Memory Model的缩写)
2.它干嘛的？：官方，其他人的博客，对应的视频！
作用：缓存一致性协议，用于定义数据读写的规则(遵守，找到这个规侧)。
JMM定义了线程工作内存和主内存之间的抽象关系：线程之间的共享变量存储在主内存(Main Memory)
中，每个线程都有一个私有的本地内存(Local Memory)

解决共享对象可见性这个问题：volilate

3.它该如何学习？
JMM:抽象的概念，理论
JMM对这八种指令的使用，制定了如下规则：
·不允许read和load、store和write操作之一单独出现。即使用了read必须load,使用了store:必须
write
·不允许线程丢弃他最近的ssign操作，即工作变量的数据改变了之后，必须告知主存
·不允许一个线程将没有assign的数据从工作内存同步回主内存
·一个新的变量必须在主内存中诞生，不允许工作内存直接使用一个未被初始化的变量。就是怼变量实
施use、storej操作之前，必须经过assign和load操作
■一个变量同一时间只有一个线程能对其进行lock。多次ock后，必须执行相同次数的unlock.才能解锁
如果对一个变量进行引0ck操作，会清空所有工作内存中此变量的值，在执行引擎使用这个变量前，必
须重新load或assign操作初始化变量的值
·如果一个变量没有被ock,就不能对其进行unlock操作。也不能unlock一个被其他线程锁住的变量
·对一个变量进行unlock操作之前，必须把此变量同步回主内存
JMM对这八种操作规则和对volatile的一些特殊规则就能确定哪里操作是线程安全，哪些操作是线程不安
全的了。但是这些规则实在复杂，很难在实践中直接分析。所以一般我们也不会通过上述规则进行分析。更多
的时候，使用java的happen-before规则来进行分析。
volatile:

## GItHub

[Github访问方法 Github被墙最新hosts 每日更新 2022年 - LabVIEWs](https://www.labviews.cn/d/16-github-githubhosts-2022)

打开“C:\Windows\System32\drivers\etc”，使用记事本修改“hosts”文件

新增一行，从[git.yoqi.me/lyq/github-host/raw/master/hosts](http://git.yoqi.me/lyq/github-host/raw/master/hosts)

最后打开cmd，执行 ipconfig/flushdns